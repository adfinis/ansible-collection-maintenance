---
- name: This task only serves as a template for the tasks below
  ansible.builtin.set_fact:
    ignoreme: &task
      name: "{{ vars.taskid }}: {{ vars.name }}"
      register: task
      when:
        - "vars.taskid not in maintenance_exclude_tasks"
        - "maintenance_only is not defined or maintenance_only == vars.taskid"
  vars:
    taskid: ignore-me
    name: bar

# Include OS specific vars to get binary name: apache_binary_name, httpd or apache2
- <<: *task
  vars:
    taskid: 32-009
    name: "Apache: Gather details, set vars: set apache binary based on OS"
  ansible.builtin.include_vars: "{{ item }}"
  with_first_found:
    - "{{ ansible_facts.os_family }}.yml"
  changed_when: false

# Get the exact binary path from the systemd service
- <<: *task
  vars:
    taskid: 32-009
    name: "Apache: Gather details, set vars: query systemd service for binary name being used"
  ansible.builtin.shell: "systemctl show -p ExecStart {{ apache_binary_name }} | grep 'ExecStart' | awk '{print $2}' | cut -d= -f2"
  register: apache_exec_path_raw
  changed_when: false
  ignore_errors: true

- <<: *task
  vars:
    taskid: 32-009
    name: "Apache: Get apache binary path used by apache systemd service"
  ansible.builtin.set_fact:
    apache_binary_path: "{{ apache_exec_path_raw.stdout if (apache_exec_path_raw.stdout | length) > 0 else 'apachectl' }}"
  changed_when: false

- <<: *task
  vars:
    taskid: 32-009
    name: "Apache: Get apache run details"
  ansible.builtin.shell: "{{ apache_binary_path }} -V && {{ apache_binary_path }} -S"
  register: apache_details
  changed_when: false

# Extract HTTP root directory
- <<: *task
  vars:
    taskid: 32-009
    name: "Apache: Extract HTTP root directory"
  ansible.builtin.set_fact:
    apache_root_directory: "{{ apache_details.stdout | regex_search('HTTPD_ROOT=\"([^\"]+)\"') | replace('\"', '') | split('=') | last }}"
  when: "'HTTPD_ROOT' in apache_details.stdout"
  changed_when: false

# Extract main server config file path
- <<: *task
  vars:
    taskid: 32-009
    name: "Apache: Extract server config file path"
  ansible.builtin.set_fact:
    apache_config_file_name: "{{ apache_root_directory + '/' + apache_details.stdout | regex_search('SERVER_CONFIG_FILE=\"([^\"]+)\"') | replace('\"', '') | split('=') | last }}"
  changed_when: false

# Extract whether SSL is enabled
- <<: *task
  vars:
    taskid: 32-009
    name: "Apache: Extract whether SSL is enabled"
  ansible.builtin.shell: "{{ apache_binary_path }} -M | grep ssl"
  register: apache_mod_ssl_output
  ignore_errors: true
  changed_when: false

# Extract whether SSL is enabled
- <<: *task
  vars:
    taskid: 32-009
    name: "Apache: Extract whether SSL is enabled"
  ansible.builtin.set_fact:
    apache_is_ssl_active: "{{ 'ssl_module' in apache_mod_ssl_output.stdout }}"
  changed_when: false

# Extract all config file regexes
- <<: *task
  vars:
    taskid: 32-009
    name: "Apache: Extract config path regexes from main apache config"
  ansible.builtin.shell:
    cmd: "grep -r '^Include' {{ apache_config_file_name }} | awk '(substr($2,0,1) != \"/\"){printf \"{{ apache_root_directory + '/' }}\"}{print $2}'"
  register: apache_included_config_paths_out
  ignore_errors: true
  changed_when: false

- <<: *task
  vars:
    taskid: 32-009
    name: "Apache: Extract config path regexes from main apache config"
  ansible.builtin.set_fact:
    apache_included_config_paths: "{{ apache_included_config_paths_out.stdout_lines }}"
  ignore_errors: true
  changed_when: false

# Find all included error log files in all configs
- <<: *task
  vars:
    taskid: 32-009
    name: "Apache: Extract log paths from apache configs"
  ansible.builtin.shell:
    cmd: "grep -rhE '^ErrorLog\\|^CustomLog' {{ item }} | awk '{print $2}'"
  loop: "{{ apache_included_config_paths }}"
  register: apache_log_files_out
  changed_when: false
  ignore_errors: true

- <<: *task
  vars:
    taskid: 32-009
    name: "Apache: Extract log paths from apache configs"
  ansible.builtin.set_fact:
    apache_log_files: "{{ apache_log_files_out.results | map(attribute='stdout_lines') | flatten }}"
  changed_when: false
  ignore_errors: true

# Add the default log paths to the list
# There might also be module specific ones in this list
- <<: *task
  vars:
    taskid: 32-009
    name: "Apache: Extract log paths from apache configs"
  ansible.builtin.set_fact:
    apache_log_files: "{{ apache_log_files | default([]) + [
                  '/var/log/{{ apache_binary_name }}/error_log',
                  '/var/log/{{ apache_binary_name }}/access_log',
                  '/var/log/{{ apache_binary_name }}/ssl_engine_log',
                  '/var/log/{{ apache_binary_name }}/rewrite.log',
                  '/var/log/{{ apache_binary_name }}/debug.log']
                }}"
  changed_when: false
  ignore_errors: true

# Find all included .pem, .crt, .key, .csr files in all apache configs
- <<: *task
  vars:
    taskid: 32-009
    name: "Apache: Extract cert paths from apache configs"
  ansible.builtin.shell:
    cmd: "grep -rhE '^\\s*(SSLCertificateFile|SSLCertificateChainFile)' {{ item }} | awk '{print $2}'"
  loop: "{{ apache_included_config_paths }}"
  register: apache_cert_files_out
  changed_when: false
  ignore_errors: true
  when: "apache_is_ssl_active is defined and apache_is_ssl_active"

- <<: *task
  vars:
    taskid: 32-009
    name: "Apache: Extract cert paths from apache configs"
  ansible.builtin.set_fact:
    apache_cert_files: "{{ apache_cert_files_out.results | map(attribute='stdout_lines') | flatten }}"
  changed_when: false
  ignore_errors: true

# Check if logrotate is working correctly for apache logs
# /var/log is also separately checked inside
# the generic linux role
- <<: *task
  vars:
    taskid: 32-010
    name: "Apache: Are there files in the apache log dir that are not rotated? | Find large files"
  ansible.builtin.find:
    paths: "{{ apache_log_files }}"
    size: 16m
    follow: true
  register: apache_large_logfiles
  changed_when: false

# Some of the files produced by the task above are sparse files, most notably /var/log/lastlog
# Use stat to figure out the actual on-disk size
- <<: *task
  vars:
    taskid: 32-010
    name: "Apache: Are there files in the apache log dir that are not rotated? | Find large files"
  ansible.builtin.stat:
    path: "{{ item }}"
    get_attributes: false
    get_checksum: false
    get_mime: false
  loop: "{{ apache_large_logfiles.files | map(attribute='path') | list }}"
  register: apache_large_logfiles_stat
  changed_when: false

- <<: *task
  vars:
    taskid: 32-010
    name: "Apache: Are there files in the apache log dir that are not rotated? | Find large files"
    # 4096 blocks equals 16M (assuming 4k logical blocksize, which is to be expected nowadays)
    apache_large_files: "{{ apache_large_logfiles_stat.results | map(attribute='stat') | selectattr('blocks', 'gt', 4096) | map(attribute='path') | list }}"
  ansible.builtin.debug:
    var: "apache_large_files"
  changed_when: "apache_large_files | length > 0"

# Check the used config file validity
- <<: *task
  vars:
    taskid: 32-012
    name: "Apache: Check apache configuration validity"
  ansible.builtin.command: "{{ apache_binary_path }} -t"
  register: apache_config_test
  changed_when: "apache_config_test.rc != 0"

# Test if cert is valid in one month
- <<: *task
  vars:
    taskid: 32-014
    name: Test whether that certificate is valid in a month
  ansible.builtin.slurp:
    src: "{{ item }}"
  register: apache_cert_files_content
  loop: "{{ apache_cert_files }}"
  changed_when: false

- <<: *task
  vars:
    taskid: 32-014
    name: Test whether that certificate is valid in a month
  community.crypto.x509_certificate_info:
    content: "{{ item }}"
    valid_at:
      one_month_later: "+1m"
  register: apache_cert_info
  loop: "{% set cert_content = [] %}{% for result in apache_cert_files_content.results %}{% for data in ([(result.content | b64decode | community.crypto.split_pem)] | flatten) %}{% set cert_content = cert_content.append(data) %}{% endfor %}{% endfor %}{{ cert_content }}"
  changed_when: false
  delegate_to: localhost

- <<: *task
  vars:
    taskid: 32-014
    name: Test whether that certificate is valid in a month
  ansible.builtin.set_fact:
    apache_cert_expires_soon: true
  loop: "{{ apache_cert_info.results }}"
  when: not (item.valid_at.one_month_later | default(true))
  loop_control:
    loop_var: item
  changed_when: false

- <<: *task
  vars:
    taskid: 32-014
    name: Test wether that certificate is valid in a month
  ansible.builtin.debug:
    msg: "At least one cert will expire in less than 1 month: {{ apache_cert_files }}"
  changed_when: apache_cert_expires_soon | default(false)

# Not printed out by default if you want to see for debugging, change changed_when to yes
- <<: *task
  vars:
    taskid: 32-009
    name: "Apache: Print apache run details"
  ansible.builtin.debug:
    msg:
      - "HTTPD root directory: {{ apache_root_directory if apache_root_directory is defined else 'Not defined' }}"
      - "Config file name: {{ apache_config_file_name if apache_config_file_name is defined else 'Not defined' }}"
      - "logfile names: {{ apache_log_files if apache_log_files is defined else 'Not defined' }}"
      - "Is SSL active: {{ apache_is_ssl_active if apache_is_ssl_active is defined else 'Not defined' }}"
      - "Included apache config paths: {{ apache_included_config_paths if apache_included_config_paths is defined else 'Not defined' }}"
      - "SSL cert paths: {{ apache_cert_files if apache_cert_files is defined else 'Not defined' }}"
  changed_when: false

- <<: *task
  vars:
    taskid: 32-009
    name: "Apache: Print apache logfiles"
  ansible.builtin.debug:
    msg:
      - "Please double check error logs for important error messages -> apache log paths: {{ apache_log_files if apache_log_files is defined else 'Not defined' }}"
  changed_when: true
